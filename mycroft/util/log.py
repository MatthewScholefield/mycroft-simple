#
# Copyright (c) 2017 Mycroft AI, Inc.
#
# This file is part of Mycroft Simple
# (see https://github.com/MatthewScholefield/mycroft-simple).
#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
#
import sys
import os
import inspect
import logging


class LOG:
    """
    Custom logger class that acts like logging.Logger
    The logger name is automatically generated by the module of the caller

    Usage:
        logger.debug('My message: %s', debug_str)
        logger('custom_name').debug('Another message')
    """

    _custom_name = None

    @classmethod
    def init(cls, config):
        cls.level = logging.getLevelName(config.get('log_level', 'DEBUG'))

        fmt = '%(asctime)s.%(msecs)03d - %(name)s - %(levelname)s - %(message)s'
        datefmt = '%H:%M:%S'
        formatter = logging.Formatter(fmt, datefmt)
        cls.fh = logging.FileHandler(config.get('log_file'), mode='w')
        cls.fh.setFormatter(formatter)
        cls.create_logger('')

    @classmethod
    def create_logger(cls, name):
        l = logging.getLogger(name)
        l.propagate = False
        if not hasattr(cls, 'fh') or not hasattr(cls, 'level'):
            return l

        l.addHandler(cls.fh)
        l.setLevel(cls.level)
        return l

    def __init__(self, name):
        LOG._custom_name = name

    @classmethod
    def _log(cls, func, msg, args):
        if LOG._custom_name is not None:
            name = LOG._custom_name
            LOG._custom_name = None
        else:
            # Stack:
            # [0] - _log()
            # [1] - debug(), info(), warning(), or error()
            # [2] - caller
            stack = inspect.stack()

            # Record:
            # [0] - frame object
            # [1] - filename
            # [2] - line number
            # [3] - function
            # ...
            record = stack[2]
            name = inspect.getmodule(record[0]).__name__ + ':' + record[3] + ':' + str(record[2])
        func(cls.create_logger(name), msg, *args)

    @staticmethod
    def debug(msg, *args):
        LOG._log(logging.Logger.debug, msg, args)

    @staticmethod
    def info(msg, *args):
        LOG._log(logging.Logger.info, msg, args)

    @staticmethod
    def warning(msg, *args):
        LOG._log(logging.Logger.warning, msg, args)

    @staticmethod
    def error(msg, *args):
        LOG._log(logging.Logger.error, msg, args)

    @staticmethod
    def print_e(e, location=''):

        typ, _, tb = sys.exc_info()[:3]
        line = tb.tb_lineno
        file = os.path.split(tb.tb_frame.f_code.co_filename)[1]
        file_line = file + ':' + str(line)
        if location != '':
            location += ', '

        intro = 'Exception in ' + location + file_line + ', '
        LOG._log(logging.Logger.warning, intro + typ.__name__ + ': ' + str(e), ())